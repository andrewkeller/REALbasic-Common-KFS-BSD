<?xml version="1.0"?>
<RBProject version="2009r5.1">
<block type="Module" ID="481833646">
 <ObjName>PropertyListKFS</ObjName>
 <ObjContainerID>385119298</ObjContainerID>
 <IsClass>1</IsClass>
 <Superclass>OrderedDictionaryKFS</Superclass>
 <ItemFlags>1</ItemFlags>
 <IsInterface>0</IsInterface>
 <Compatibility></Compatibility>
 <Method>
  <ItemName>Child</ItemName>
  <Compatibility></Compatibility>
  <Visible>1</Visible>
  <ItemSource>
   <TextEncoding>134217984</TextEncoding>
   <SourceLine>Function Child(key As Variant, setAsType As Integer = -1) As PropertyListKFS</SourceLine>
   <SourceLine>// Created 1/7/2010 by Andrew Keller</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>// A standard child function, except that we must first</SourceLine>
   <SourceLine>// figure out whether the key is an index or not.</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>// Super.Key and Super.Value in the last block may throw exceptions.</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Dim result As PropertyListKFS</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>If setAsType &gt; -1 And Me.HasKey( key ) Then</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>If IsIndex( key ) Then</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>result = Super.Value( Super.Key( key ) )</SourceLine>
   <SourceLine>Else</SourceLine>
   <SourceLine>result = Super.Value( key )</SourceLine>
   <SourceLine>End If</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>result.Type = setAsType</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>ElseIf setAsType &gt; -1 Then</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>result = New PropertyListKFS( setAsType )</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>result.Type = setAsType</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Me.Child( key ) = result</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Else</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>If IsIndex( key ) Then</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>result = Super.Value( Super.Key( key ) )</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Else</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>result = Super.Value( key )</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>End If</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>End If</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Return result</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>// done.</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>End Function</SourceLine>
  </ItemSource>
  <TextEncoding>134217984</TextEncoding>
  <AliasName></AliasName>
  <ItemFlags>0</ItemFlags>
  <Shared>0</Shared>
  <ItemParams>key As Variant, setAsType As Integer = -1</ItemParams>
  <ItemResult>PropertyListKFS</ItemResult>
 </Method>
 <Method>
  <ItemName>Child</ItemName>
  <Compatibility></Compatibility>
  <Visible>1</Visible>
  <ItemSource>
   <TextEncoding>134217984</TextEncoding>
   <SourceLine>Sub Child(key As Variant, Assigns newChild As PropertyListKFS)</SourceLine>
   <SourceLine>// Created 1/7/2010 by Andrew Keller</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>// A standard child function, except that we must first</SourceLine>
   <SourceLine>// figure out whether the key is an index or not.</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>If IsIndex( key ) Then</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>If key &lt; 0 Or key &gt; Me.Count Then Raise New OutOfBoundsException</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>If key = Me.Count Then</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Super.Value( NewUnusedKey ) = newChild</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Else</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Super.Value( Super.Key( key ) ) = newChild</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>End If</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Else</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Super.Value( key.StringValue ) = newChild</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>End If</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>// done.</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>End Sub</SourceLine>
  </ItemSource>
  <TextEncoding>134217984</TextEncoding>
  <AliasName></AliasName>
  <ItemFlags>0</ItemFlags>
  <Shared>0</Shared>
  <ItemParams>key As Variant, Assigns newChild As PropertyListKFS</ItemParams>
  <ItemResult></ItemResult>
 </Method>
 <Method>
  <ItemName>Value</ItemName>
  <Compatibility></Compatibility>
  <Visible>1</Visible>
  <ItemSource>
   <TextEncoding>134217984</TextEncoding>
   <SourceLine>Function Value(key As Variant) As Variant</SourceLine>
   <SourceLine>// Created 1/7/2010 by Andrew Keller</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>// A standard Value function, except that it is abstracted at</SourceLine>
   <SourceLine>// this layer (meaning key could be either an index or a key).</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>// Me.Child may throw an exception.</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Return Me.Child( key ).Value</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>// done.</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>End Function</SourceLine>
  </ItemSource>
  <TextEncoding>134217984</TextEncoding>
  <AliasName></AliasName>
  <ItemFlags>0</ItemFlags>
  <Shared>0</Shared>
  <ItemParams>key As Variant</ItemParams>
  <ItemResult>Variant</ItemResult>
 </Method>
 <Method>
  <ItemName>Value</ItemName>
  <Compatibility></Compatibility>
  <Visible>1</Visible>
  <ItemSource>
   <TextEncoding>134217984</TextEncoding>
   <SourceLine>Sub Value(key As Variant, Assigns _value As Variant)</SourceLine>
   <SourceLine>// Created 1/7/2010 by Andrew Keller</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>// A standard Value function, except that it is abstracted at</SourceLine>
   <SourceLine>// this layer (meaning key could be either an index or a key).</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Me.Value( key, GetDataType( _value ) ) = _value</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>// done.</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>End Sub</SourceLine>
  </ItemSource>
  <TextEncoding>134217984</TextEncoding>
  <AliasName></AliasName>
  <ItemFlags>0</ItemFlags>
  <Shared>0</Shared>
  <ItemParams>key As Variant, Assigns _value As Variant</ItemParams>
  <ItemResult></ItemResult>
 </Method>
 <Method>
  <ItemName>Children</ItemName>
  <Compatibility></Compatibility>
  <Visible>1</Visible>
  <ItemSource>
   <TextEncoding>134217984</TextEncoding>
   <SourceLine>Function Children() As PropertyListKFS()</SourceLine>
   <SourceLine>// Created 1/7/2010 by Andrew Keller</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>// Returns an array of all the children in this instance.</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Dim tmp() As Variant = Super.Values</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Dim row, last As Integer = UBound( tmp )</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Dim result() As PropertyListKFS</SourceLine>
   <SourceLine>ReDim result( last )</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>For row = 0 To last</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>result( row ) = PropertyListKFS( tmp( row ) )</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Next</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Return result</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>// done.</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>End Function</SourceLine>
  </ItemSource>
  <TextEncoding>134217984</TextEncoding>
  <AliasName></AliasName>
  <ItemFlags>0</ItemFlags>
  <Shared>0</Shared>
  <ItemParams></ItemParams>
  <ItemResult>PropertyListKFS()</ItemResult>
 </Method>
 <Method>
  <ItemName>Clear</ItemName>
  <Compatibility></Compatibility>
  <Visible>1</Visible>
  <ItemSource>
   <TextEncoding>134217984</TextEncoding>
   <SourceLine>Sub Clear()</SourceLine>
   <SourceLine>// Created 1/7/2010 by Andrew Keller</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>// Clears this instance of all data.</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Super.Clear</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>IsModified = False</SourceLine>
   <SourceLine>myValue = Nil</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>// done.</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>End Sub</SourceLine>
  </ItemSource>
  <TextEncoding>134217984</TextEncoding>
  <AliasName></AliasName>
  <ItemFlags>0</ItemFlags>
  <Shared>0</Shared>
  <ItemParams></ItemParams>
  <ItemResult></ItemResult>
 </Method>
 <Method>
  <ItemName>IndexOf</ItemName>
  <Compatibility></Compatibility>
  <Visible>1</Visible>
  <ItemSource>
   <TextEncoding>134217984</TextEncoding>
   <SourceLine>Function IndexOf(key As Variant) As Integer</SourceLine>
   <SourceLine>// Created 1/7/2010 by Andrew Keller</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>// A standard IndexOf function, except that we must first</SourceLine>
   <SourceLine>// figure out whether the key is an index or not.</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>If IsIndex( key ) Then</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Return key</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Else</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Return Super.IndexOf( key )</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>End If</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>// done.</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>End Function</SourceLine>
  </ItemSource>
  <TextEncoding>134217984</TextEncoding>
  <AliasName></AliasName>
  <ItemFlags>0</ItemFlags>
  <Shared>0</Shared>
  <ItemParams>key As Variant</ItemParams>
  <ItemResult>Integer</ItemResult>
 </Method>
 <Method>
  <ItemName>IndexOf</ItemName>
  <Compatibility></Compatibility>
  <Visible>1</Visible>
  <ItemSource>
   <TextEncoding>134217984</TextEncoding>
   <SourceLine>Sub IndexOf(key As Variant, Assigns newPosition As Integer)</SourceLine>
   <SourceLine>// Created 1/7/2010 by Andrew Keller</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>// A standard IndexOf function, except that we must first</SourceLine>
   <SourceLine>// figure out whether the key is an index or not.</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>If IsIndex( key ) Then</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Super.MoveIndex( key, newPosition )</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Else</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Super.IndexOf( key ) = newPosition</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>End If</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>// done.</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>End Sub</SourceLine>
  </ItemSource>
  <TextEncoding>134217984</TextEncoding>
  <AliasName></AliasName>
  <ItemFlags>0</ItemFlags>
  <Shared>0</Shared>
  <ItemParams>key As Variant, Assigns newPosition As Integer</ItemParams>
  <ItemResult></ItemResult>
 </Method>
 <Method>
  <ItemName>Remove</ItemName>
  <Compatibility></Compatibility>
  <Visible>1</Visible>
  <ItemSource>
   <TextEncoding>134217984</TextEncoding>
   <SourceLine>Sub Remove(key As Variant)</SourceLine>
   <SourceLine>// Created 1/7/2010 by Andrew Keller</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>// A standard Remove function, but first we have to figure</SourceLine>
   <SourceLine>// out whether the given key is an index or not.</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>// Super.Remove and Super.Key may throw exceptions.</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>If IsIndex( key ) Then</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Super.Remove( Super.Key( key ) )</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Else</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Super.Remove( key )</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>End If</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>// done.</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>End Sub</SourceLine>
  </ItemSource>
  <TextEncoding>134217984</TextEncoding>
  <AliasName></AliasName>
  <ItemFlags>0</ItemFlags>
  <Shared>0</Shared>
  <ItemParams>key As Variant</ItemParams>
  <ItemResult></ItemResult>
 </Method>
 <Method>
  <ItemName>Constructor</ItemName>
  <Compatibility></Compatibility>
  <Visible>1</Visible>
  <ItemSource>
   <TextEncoding>134217984</TextEncoding>
   <SourceLine>Sub Constructor(ParamArray entries As Pair)</SourceLine>
   <SourceLine>// Created 1/7/2010 by Andrew Keller</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>// Simple constructor that adds the given key-value pairs</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Constructor entries</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>// done.</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>End Sub</SourceLine>
  </ItemSource>
  <TextEncoding>134217984</TextEncoding>
  <AliasName></AliasName>
  <ItemFlags>4096</ItemFlags>
  <Shared>0</Shared>
  <ItemParams>ParamArray entries As Pair</ItemParams>
  <ItemResult></ItemResult>
 </Method>
 <Method>
  <ItemName>Constructor</ItemName>
  <Compatibility></Compatibility>
  <Visible>1</Visible>
  <ItemSource>
   <TextEncoding>134217984</TextEncoding>
   <SourceLine>Sub Constructor(entries() As Pair)</SourceLine>
   <SourceLine>// Created 1/7/2010 by Andrew Keller</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>// Simple constructor that adds the given key-value pairs</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Super.Constructor entries</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>AutoSaveInDestructor = False</SourceLine>
   <SourceLine>myDataIsModified = False</SourceLine>
   <SourceLine>myType = kNodeTypeDictionary</SourceLine>
   <SourceLine>myValue = Nil</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>// done.</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>End Sub</SourceLine>
  </ItemSource>
  <TextEncoding>134217984</TextEncoding>
  <AliasName></AliasName>
  <ItemFlags>4096</ItemFlags>
  <Shared>0</Shared>
  <ItemParams>entries() As Pair</ItemParams>
  <ItemResult></ItemResult>
 </Method>
 <Method>
  <ItemName>HasKey</ItemName>
  <Compatibility></Compatibility>
  <Visible>1</Visible>
  <ItemSource>
   <TextEncoding>134217984</TextEncoding>
   <SourceLine>Function HasKey(key As Variant) As Boolean</SourceLine>
   <SourceLine>// Created 1/7/2010 by Andrew Keller</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>// A standard HasKey function, but first we have to figure</SourceLine>
   <SourceLine>// out whether the given key is an index or not.</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>If IsIndex( key ) Then</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Return key.IntegerValue &gt;=0 And key.IntegerValue &lt; Me.Count</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Else</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Return Super.HasKey( key.StringValue )</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>End If</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>// done.</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>End Function</SourceLine>
  </ItemSource>
  <TextEncoding>134217984</TextEncoding>
  <AliasName></AliasName>
  <ItemFlags>0</ItemFlags>
  <Shared>0</Shared>
  <ItemParams>key As Variant</ItemParams>
  <ItemResult>Boolean</ItemResult>
 </Method>
 <Method>
  <ItemName>Lookup</ItemName>
  <Compatibility></Compatibility>
  <Visible>1</Visible>
  <ItemSource>
   <TextEncoding>134217984</TextEncoding>
   <SourceLine>Function Lookup(key As Variant, defaultValue As Variant) As Variant</SourceLine>
   <SourceLine>// Created 1/7/2010 by Andrew Keller</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>// A standard Value function, except that it is abstracted at</SourceLine>
   <SourceLine>// this layer (meaning key could be either an index or a key).</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>If Me.HasKey( key ) Then</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Return Value( key )</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Else</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Return defaultValue</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>End If</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>// done.</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>End Function</SourceLine>
  </ItemSource>
  <TextEncoding>134217984</TextEncoding>
  <AliasName></AliasName>
  <ItemFlags>0</ItemFlags>
  <Shared>0</Shared>
  <ItemParams>key As Variant, defaultValue As Variant</ItemParams>
  <ItemResult>Variant</ItemResult>
 </Method>
 <Method>
  <ItemName>IsModified</ItemName>
  <Compatibility></Compatibility>
  <Visible>1</Visible>
  <ItemSource>
   <TextEncoding>134217984</TextEncoding>
   <SourceLine>Function IsModified() As Boolean</SourceLine>
   <SourceLine>// Created 1/7/2010 by Andrew Keller</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>// Returns whether or not this instance</SourceLine>
   <SourceLine>// or any of its children are modified.</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>If myDataIsModified Then Return True</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>For Each child As PropertyListKFS In Me.Children</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>If child.IsModified Then Return True</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Next</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Return False</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>// done.</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>End Function</SourceLine>
  </ItemSource>
  <TextEncoding>134217984</TextEncoding>
  <AliasName></AliasName>
  <ItemFlags>1</ItemFlags>
  <Shared>0</Shared>
  <ItemParams></ItemParams>
  <ItemResult>Boolean</ItemResult>
 </Method>
 <Method>
  <ItemName>IsModified</ItemName>
  <Compatibility></Compatibility>
  <Visible>1</Visible>
  <ItemSource>
   <TextEncoding>134217984</TextEncoding>
   <SourceLine>Sub IsModified(Assigns b As Boolean)</SourceLine>
   <SourceLine>// Created 1/7/2010 by Andrew Keller</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>// Either marks this instance as modified, or marks</SourceLine>
   <SourceLine>// this instance and all of its children as not modified.</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>If b Then</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>myDataIsModified = True</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Else</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>myDataIsModified = False</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>For Each child As PropertyListKFS In Me.Children</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>child.IsModified = False</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Next</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>End If</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>// done.</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>End Sub</SourceLine>
  </ItemSource>
  <TextEncoding>134217984</TextEncoding>
  <AliasName></AliasName>
  <ItemFlags>1</ItemFlags>
  <Shared>0</Shared>
  <ItemParams>Assigns b As Boolean</ItemParams>
  <ItemResult></ItemResult>
 </Method>
 <Method>
  <ItemName>IsIndex</ItemName>
  <Compatibility></Compatibility>
  <Visible>1</Visible>
  <ItemSource>
   <TextEncoding>134217984</TextEncoding>
   <SourceLine>Function IsIndex(key As Variant) As Boolean</SourceLine>
   <SourceLine>// Created 1/7/2010 by Andrew Keller</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>// Returns whether or not the given key should be treated as an index.</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Dim type As Integer = VarType( key )</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Select Case type</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Case Variant.TypeInteger</SourceLine>
   <SourceLine>Return True</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Case Variant.TypeLong</SourceLine>
   <SourceLine>Return True</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Case Variant.TypeSingle</SourceLine>
   <SourceLine>Return True</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>End Select</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Return False</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>// done.</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>End Function</SourceLine>
  </ItemSource>
  <TextEncoding>134217984</TextEncoding>
  <AliasName></AliasName>
  <ItemFlags>1</ItemFlags>
  <Shared>0</Shared>
  <ItemParams>key As Variant</ItemParams>
  <ItemResult>Boolean</ItemResult>
 </Method>
 <Method>
  <ItemName>Value</ItemName>
  <Compatibility></Compatibility>
  <Visible>1</Visible>
  <ItemSource>
   <TextEncoding>134217984</TextEncoding>
   <SourceLine>Sub Value(key As Variant, setAsType As Integer, Assigns _value As Variant)</SourceLine>
   <SourceLine>// Created 1/7/2010 by Andrew Keller</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>// A standard Value function, except that it is abstracted at</SourceLine>
   <SourceLine>// this layer (meaning key could be either an index or a key).</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Me.Child( key, setAsType ).Value = _value</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>// done.</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>End Sub</SourceLine>
  </ItemSource>
  <TextEncoding>134217984</TextEncoding>
  <AliasName></AliasName>
  <ItemFlags>0</ItemFlags>
  <Shared>0</Shared>
  <ItemParams>key As Variant, setAsType As Integer, Assigns _value As Variant</ItemParams>
  <ItemResult></ItemResult>
 </Method>
 <Method>
  <ItemName>Value</ItemName>
  <Compatibility></Compatibility>
  <Visible>1</Visible>
  <ItemSource>
   <TextEncoding>134217984</TextEncoding>
   <SourceLine>Function Value() As Variant</SourceLine>
   <SourceLine>// Created 1/7/2010 by Andrew Keller</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>// Returns the current value in this instance.</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Return myValue</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>// done.</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>End Function</SourceLine>
  </ItemSource>
  <TextEncoding>134217984</TextEncoding>
  <AliasName></AliasName>
  <ItemFlags>0</ItemFlags>
  <Shared>0</Shared>
  <ItemParams></ItemParams>
  <ItemResult>Variant</ItemResult>
 </Method>
 <Method>
  <ItemName>Type</ItemName>
  <Compatibility></Compatibility>
  <Visible>1</Visible>
  <ItemSource>
   <TextEncoding>134217984</TextEncoding>
   <SourceLine>Function Type() As Integer</SourceLine>
   <SourceLine>// Created 1/7/2010 by Andrew Keller</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>// Returns the current type of this instance.</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Return myType</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>// done.</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>End Function</SourceLine>
  </ItemSource>
  <TextEncoding>134217984</TextEncoding>
  <AliasName></AliasName>
  <ItemFlags>0</ItemFlags>
  <Shared>0</Shared>
  <ItemParams></ItemParams>
  <ItemResult>Integer</ItemResult>
 </Method>
 <Method>
  <ItemName>Type</ItemName>
  <Compatibility></Compatibility>
  <Visible>1</Visible>
  <ItemSource>
   <TextEncoding>134217984</TextEncoding>
   <SourceLine>Sub Type(Assigns newType As Integer)</SourceLine>
   <SourceLine>// Created 1/7/2010 by Andrew Keller</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>// Sets the type of this instance.</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>myType = newType</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>// done.</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>End Sub</SourceLine>
  </ItemSource>
  <TextEncoding>134217984</TextEncoding>
  <AliasName></AliasName>
  <ItemFlags>0</ItemFlags>
  <Shared>0</Shared>
  <ItemParams>Assigns newType As Integer</ItemParams>
  <ItemResult></ItemResult>
 </Method>
 <Method>
  <ItemName>Value</ItemName>
  <Compatibility></Compatibility>
  <Visible>1</Visible>
  <ItemSource>
   <TextEncoding>134217984</TextEncoding>
   <SourceLine>Sub Value(Assigns newValue As Variant)</SourceLine>
   <SourceLine>// Created 1/7/2010 by Andrew Keller</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>// Sets the value in this instance.</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>myValue = newValue</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>// done.</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>End Sub</SourceLine>
  </ItemSource>
  <TextEncoding>134217984</TextEncoding>
  <AliasName></AliasName>
  <ItemFlags>0</ItemFlags>
  <Shared>0</Shared>
  <ItemParams>Assigns newValue As Variant</ItemParams>
  <ItemResult></ItemResult>
 </Method>
 <Method>
  <ItemName>Constructor</ItemName>
  <Compatibility></Compatibility>
  <Visible>1</Visible>
  <ItemSource>
   <TextEncoding>134217984</TextEncoding>
   <SourceLine>Sub Constructor(setAsType As Integer)</SourceLine>
   <SourceLine>// Created 1/7/2010 by Andrew Keller</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>// Constructor that takes a type.</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Super.Constructor</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>AutoSaveInDestructor = False</SourceLine>
   <SourceLine>myDataIsModified = False</SourceLine>
   <SourceLine>myType = setAsType</SourceLine>
   <SourceLine>myValue = Nil</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>// done.</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>End Sub</SourceLine>
  </ItemSource>
  <TextEncoding>134217984</TextEncoding>
  <AliasName></AliasName>
  <ItemFlags>4096</ItemFlags>
  <Shared>0</Shared>
  <ItemParams>setAsType As Integer</ItemParams>
  <ItemResult></ItemResult>
 </Method>
 <Method>
  <ItemName>GetDataType</ItemName>
  <Compatibility></Compatibility>
  <Visible>1</Visible>
  <ItemSource>
   <TextEncoding>134217984</TextEncoding>
   <SourceLine>Function GetDataType(data As Variant) As Integer</SourceLine>
   <SourceLine>// Created 1/7/2010 by Andrew Keller</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>// Returns the type of the given variant.</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>If data = Nil Then Return kNodeTypeBoolean</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>If data.IsArray Then Return kNodeTypeArray</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Dim type As Integer = VarType( data )</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Select Case type</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Case Variant.TypeBoolean</SourceLine>
   <SourceLine>Return kNodeTypeBoolean</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Case Variant.TypeCFStringRef</SourceLine>
   <SourceLine>Return kNodeTypeString</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Case Variant.TypeColor</SourceLine>
   <SourceLine>Return kNodeTypeNumber</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Case Variant.TypeCString</SourceLine>
   <SourceLine>Return kNodeTypeString</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Case Variant.TypeCurrency</SourceLine>
   <SourceLine>Return kNodeTypeNumber</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Case Variant.TypeDate</SourceLine>
   <SourceLine>Return kNodeTypeDate</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Case Variant.TypeDouble</SourceLine>
   <SourceLine>Return kNodeTypeNumber</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Case Variant.TypeInteger</SourceLine>
   <SourceLine>Return kNodeTypeNumber</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Case Variant.TypeLong</SourceLine>
   <SourceLine>Return kNodeTypeNumber</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Case Variant.TypeNil</SourceLine>
   <SourceLine>Return kNodeTypeBoolean</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Case Variant.TypeObject</SourceLine>
   <SourceLine>Return kNodeTypeData</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Case Variant.TypeOSType</SourceLine>
   <SourceLine>Return kNodeTypeNumber</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Case Variant.TypePString</SourceLine>
   <SourceLine>Return kNodeTypeString</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Case Variant.TypePtr</SourceLine>
   <SourceLine>Return kNodeTypeNumber</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Case Variant.TypeSingle</SourceLine>
   <SourceLine>Return kNodeTypeNumber</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Case Variant.TypeString</SourceLine>
   <SourceLine>Return kNodeTypeString</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Case Variant.TypeStructure</SourceLine>
   <SourceLine>Return kNodeTypeData</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Case Variant.TypeWindowPtr</SourceLine>
   <SourceLine>Return kNodeTypeNumber</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Case Variant.TypeWString</SourceLine>
   <SourceLine>Return kNodeTypeString</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>End Select</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Return kNodeTypeData</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>// done.</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>End Function</SourceLine>
  </ItemSource>
  <TextEncoding>134217984</TextEncoding>
  <AliasName></AliasName>
  <ItemFlags>33</ItemFlags>
  <Shared>0</Shared>
  <ItemParams>data As Variant</ItemParams>
  <ItemResult>Integer</ItemResult>
 </Method>
 <Method>
  <ItemName>Revert</ItemName>
  <Compatibility></Compatibility>
  <Visible>1</Visible>
  <ItemSource>
   <TextEncoding>134217984</TextEncoding>
   <SourceLine>Sub Revert()</SourceLine>
   <SourceLine>// Created 1/7/2009 by Andrew Keller</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>// Doesn't actually do anything.</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>// This function exists here for easy access to the</SourceLine>
   <SourceLine>// Revert function in any subclasses, when they are</SourceLine>
   <SourceLine>// applicable.  This way, you can call Revert on any</SourceLine>
   <SourceLine>// instance of PropertyListKFS without actually knowing</SourceLine>
   <SourceLine>// what type it is, or even if it will revert to something.</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>// done.</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>End Sub</SourceLine>
  </ItemSource>
  <TextEncoding>134217984</TextEncoding>
  <AliasName></AliasName>
  <ItemFlags>0</ItemFlags>
  <Shared>0</Shared>
  <ItemParams></ItemParams>
  <ItemResult></ItemResult>
 </Method>
 <Method>
  <ItemName>Save</ItemName>
  <Compatibility></Compatibility>
  <Visible>1</Visible>
  <ItemSource>
   <TextEncoding>134217984</TextEncoding>
   <SourceLine>Sub Save()</SourceLine>
   <SourceLine>// Created 1/7/2009 by Andrew Keller</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>// Doesn't actually do anything.</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>// This function exists here for easy access to the</SourceLine>
   <SourceLine>// Save function in any subclasses, when they are</SourceLine>
   <SourceLine>// applicable.  This way, you can call Save on any</SourceLine>
   <SourceLine>// instance of PropertyListKFS without actually knowing</SourceLine>
   <SourceLine>// what type it is, or even if it will save to something.</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>// done.</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>End Sub</SourceLine>
  </ItemSource>
  <TextEncoding>134217984</TextEncoding>
  <AliasName></AliasName>
  <ItemFlags>0</ItemFlags>
  <Shared>0</Shared>
  <ItemParams></ItemParams>
  <ItemResult></ItemResult>
 </Method>
 <Method>
  <ItemName>Destructor</ItemName>
  <Compatibility></Compatibility>
  <Visible>1</Visible>
  <ItemSource>
   <TextEncoding>134217984</TextEncoding>
   <SourceLine>Sub Destructor()</SourceLine>
   <SourceLine>// Created 1/7/2009 by Andrew Keller</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>// Standard Destructor.</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>// Save this instance to origin?</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>If AutoSaveInDestructor Then</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Save</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>End If</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>// done.</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>End Sub</SourceLine>
  </ItemSource>
  <TextEncoding>134217984</TextEncoding>
  <AliasName></AliasName>
  <ItemFlags>0</ItemFlags>
  <Shared>0</Shared>
  <ItemParams></ItemParams>
  <ItemResult></ItemResult>
 </Method>
 <Method>
  <ItemName>Open</ItemName>
  <Compatibility></Compatibility>
  <Visible>1</Visible>
  <ItemSource>
   <TextEncoding>134217984</TextEncoding>
   <SourceLine> Shared Function Open(file As FolderItem) As PropertyListKFS</SourceLine>
   <SourceLine>// Created 1/7/2010 by Andrew Keller</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>// Provides an alternate syntax for initializing</SourceLine>
   <SourceLine>// a PropertyListKFS instance from a file.</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>If file = Nil Then Raise New NilObjectException</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Return file.OpenAsPropertyListKFS</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>// done.</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>End Function</SourceLine>
  </ItemSource>
  <TextEncoding>134217984</TextEncoding>
  <AliasName></AliasName>
  <ItemFlags>0</ItemFlags>
  <Shared>1</Shared>
  <ItemParams>file As FolderItem</ItemParams>
  <ItemResult>PropertyListKFS</ItemResult>
 </Method>
 <Method>
  <ItemName>Revert</ItemName>
  <Compatibility></Compatibility>
  <Visible>1</Visible>
  <ItemSource>
   <TextEncoding>134217984</TextEncoding>
   <SourceLine>Sub Revert(src As PropertyListKFS)</SourceLine>
   <SourceLine>// Created 1/7/2009 by Andrew Keller</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>// Reinitializes this instance with the data contained in the given PropertyListKFS.</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Clear</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>If src &lt;&gt; Nil Then</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>// Import the value in src</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>myValue = src.myValue</SourceLine>
   <SourceLine>myType = src.myType</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>// Import the children in src</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Dim index, last As Integer</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>last = src.Count -1</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>For index = 0 To last</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Dim k As String = src.Key( index )</SourceLine>
   <SourceLine>Dim c As PropertyListKFS = src.Child( index )</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Me.Child( k, c.Type ).Revert c</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Next</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>End If</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>// done.</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>End Sub</SourceLine>
  </ItemSource>
  <TextEncoding>134217984</TextEncoding>
  <AliasName></AliasName>
  <ItemFlags>0</ItemFlags>
  <Shared>0</Shared>
  <ItemParams>src As PropertyListKFS</ItemParams>
  <ItemResult></ItemResult>
 </Method>
 <Method>
  <ItemName>NewUnusedKey</ItemName>
  <Compatibility></Compatibility>
  <Visible>1</Visible>
  <ItemSource>
   <TextEncoding>134217984</TextEncoding>
   <SourceLine>Function NewUnusedKey() As String</SourceLine>
   <SourceLine>// Created 1/8/2010 by Andrew Keller</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>// Returns a key that is not used in this instance.</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Dim result As String</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Do</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>result = "default_key_" + str( GetUniqueIndexKFS( "PropertyListKFS.NewUnusedKey" ) )</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Loop Until Not Me.HasKey( result )</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Return result</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>// done.</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>End Function</SourceLine>
  </ItemSource>
  <TextEncoding>134217984</TextEncoding>
  <AliasName></AliasName>
  <ItemFlags>33</ItemFlags>
  <Shared>0</Shared>
  <ItemParams></ItemParams>
  <ItemResult>String</ItemResult>
 </Method>
 <Method>
  <ItemName>Type_Localized</ItemName>
  <Compatibility></Compatibility>
  <Visible>1</Visible>
  <ItemSource>
   <TextEncoding>134217984</TextEncoding>
   <SourceLine>Function Type_Localized() As String</SourceLine>
   <SourceLine>// Created 1/8/2010 by Andrew Keller</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>// Returns a human-readable representation</SourceLine>
   <SourceLine>// of the type of this class.</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Select Case Type</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Case kNodeTypeDictionary</SourceLine>
   <SourceLine>Return "Dictionary"</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Case kNodeTypeArray</SourceLine>
   <SourceLine>Return "Array"</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Case kNodeTypeBoolean</SourceLine>
   <SourceLine>Return "Boolean"</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Case kNodeTypeNumber</SourceLine>
   <SourceLine>Return "Number"</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Case kNodeTypeString</SourceLine>
   <SourceLine>Return "String"</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Case kNodeTypeDate</SourceLine>
   <SourceLine>Return "Date"</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Case kNodeTypeData</SourceLine>
   <SourceLine>Return "Data"</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Else</SourceLine>
   <SourceLine>Return "[Invalid Type]"</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>End Select</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>// done.</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>End Function</SourceLine>
  </ItemSource>
  <TextEncoding>134217984</TextEncoding>
  <AliasName></AliasName>
  <ItemFlags>0</ItemFlags>
  <Shared>0</Shared>
  <ItemParams></ItemParams>
  <ItemResult>String</ItemResult>
 </Method>
 <Property>
  <ItemName>myValue</ItemName>
  <Compatibility></Compatibility>
  <Visible>1</Visible>
  <ItemSource>
   <TextEncoding>134217984</TextEncoding>
   <SourceLine>myValue As Variant</SourceLine>
   <SourceLine></SourceLine>
  </ItemSource>
  <TextEncoding>134217984</TextEncoding>
  <ItemDeclaration>myValue As Variant</ItemDeclaration>
  <ItemFlags>33</ItemFlags>
  <Shared>0</Shared>
 </Property>
 <Property>
  <ItemName>myType</ItemName>
  <Compatibility></Compatibility>
  <Visible>1</Visible>
  <ItemSource>
   <TextEncoding>134217984</TextEncoding>
   <SourceLine>myType As Integer</SourceLine>
   <SourceLine></SourceLine>
  </ItemSource>
  <TextEncoding>134217984</TextEncoding>
  <ItemDeclaration>myType As Integer</ItemDeclaration>
  <ItemFlags>33</ItemFlags>
  <Shared>0</Shared>
 </Property>
 <Property>
  <ItemName>myDataIsModified</ItemName>
  <Compatibility></Compatibility>
  <Visible>1</Visible>
  <ItemSource>
   <TextEncoding>134217984</TextEncoding>
   <SourceLine>myDataIsModified As Boolean</SourceLine>
   <SourceLine></SourceLine>
  </ItemSource>
  <TextEncoding>134217984</TextEncoding>
  <ItemDeclaration>myDataIsModified As Boolean</ItemDeclaration>
  <ItemFlags>33</ItemFlags>
  <Shared>0</Shared>
 </Property>
 <Property>
  <ItemName>AutoSaveInDestructor</ItemName>
  <Compatibility></Compatibility>
  <Visible>1</Visible>
  <ItemSource>
   <TextEncoding>134217984</TextEncoding>
   <SourceLine>AutoSaveInDestructor As Boolean</SourceLine>
   <SourceLine>Almost doesn't do anything.</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>This property is shared amongst most of the subclasses</SourceLine>
   <SourceLine>of this class, making it eligible for being in this</SourceLine>
   <SourceLine>layer.  This way, you can tell whether or not an</SourceLine>
   <SourceLine>arbitrary PropertyListKFS will save in the destructor</SourceLine>
   <SourceLine>or not, without knowing which subclass it is, or if</SourceLine>
   <SourceLine>Save will even do anything.</SourceLine>
   <SourceLine></SourceLine>
  </ItemSource>
  <TextEncoding>134217984</TextEncoding>
  <ItemDeclaration>AutoSaveInDestructor As Boolean</ItemDeclaration>
  <ItemFlags>0</ItemFlags>
  <Shared>0</Shared>
 </Property>
 <ViewBehavior>
  <ViewProperty>
   <ObjName>Name</ObjName>
   <Visible>1</Visible>
   <PropertyGroup>ID</PropertyGroup>
   <InheritsFrom>Object</InheritsFrom>
  </ViewProperty>
  <ViewProperty>
   <ObjName>Index</ObjName>
   <Visible>1</Visible>
   <PropertyGroup>ID</PropertyGroup>
   <PropertyValue>-2147483648</PropertyValue>
   <InheritsFrom>Object</InheritsFrom>
  </ViewProperty>
  <ViewProperty>
   <ObjName>Super</ObjName>
   <Visible>1</Visible>
   <PropertyGroup>ID</PropertyGroup>
   <InheritsFrom>Object</InheritsFrom>
  </ViewProperty>
  <ViewProperty>
   <ObjName>Left</ObjName>
   <Visible>1</Visible>
   <PropertyGroup>Position</PropertyGroup>
   <PropertyValue>0</PropertyValue>
   <InheritsFrom>Object</InheritsFrom>
  </ViewProperty>
  <ViewProperty>
   <ObjName>Top</ObjName>
   <Visible>1</Visible>
   <PropertyGroup>Position</PropertyGroup>
   <PropertyValue>0</PropertyValue>
   <InheritsFrom>Object</InheritsFrom>
  </ViewProperty>
  <ViewProperty>
   <ObjName>AutoSaveInDestructor</ObjName>
   <PropertyGroup>Behavior</PropertyGroup>
   <ItemType>Boolean</ItemType>
  </ViewProperty>
 </ViewBehavior>
 <Constant>
  <ItemName>kNodeTypeNumber</ItemName>
  <Compatibility></Compatibility>
  <Visible>1</Visible>
  <TextEncoding>134217984</TextEncoding>
  <ItemName>kNodeTypeNumber</ItemName>
  <ItemType>2</ItemType>
  <ItemDef>3</ItemDef>
  <ItemFlags>0</ItemFlags>
 </Constant>
 <Constant>
  <ItemName>kNodeTypeArray</ItemName>
  <Compatibility></Compatibility>
  <Visible>1</Visible>
  <TextEncoding>134217984</TextEncoding>
  <ItemName>kNodeTypeArray</ItemName>
  <ItemType>2</ItemType>
  <ItemDef>1</ItemDef>
  <ItemFlags>0</ItemFlags>
 </Constant>
 <Constant>
  <ItemName>kNodeTypeDictionary</ItemName>
  <Compatibility></Compatibility>
  <Visible>1</Visible>
  <TextEncoding>134217984</TextEncoding>
  <ItemName>kNodeTypeDictionary</ItemName>
  <ItemType>2</ItemType>
  <ItemDef>0</ItemDef>
  <ItemFlags>0</ItemFlags>
 </Constant>
 <Constant>
  <ItemName>kNodeTypeDate</ItemName>
  <Compatibility></Compatibility>
  <Visible>1</Visible>
  <TextEncoding>134217984</TextEncoding>
  <ItemName>kNodeTypeDate</ItemName>
  <ItemType>2</ItemType>
  <ItemDef>5</ItemDef>
  <ItemFlags>0</ItemFlags>
 </Constant>
 <Constant>
  <ItemName>kNodeTypeData</ItemName>
  <Compatibility></Compatibility>
  <Visible>1</Visible>
  <TextEncoding>134217984</TextEncoding>
  <ItemName>kNodeTypeData</ItemName>
  <ItemType>2</ItemType>
  <ItemDef>6</ItemDef>
  <ItemFlags>0</ItemFlags>
 </Constant>
 <Constant>
  <ItemName>kNodeTypeString</ItemName>
  <Compatibility></Compatibility>
  <Visible>1</Visible>
  <TextEncoding>134217984</TextEncoding>
  <ItemName>kNodeTypeString</ItemName>
  <ItemType>2</ItemType>
  <ItemDef>4</ItemDef>
  <ItemFlags>0</ItemFlags>
 </Constant>
 <Constant>
  <ItemName>kNodeTypeBoolean</ItemName>
  <Compatibility></Compatibility>
  <Visible>1</Visible>
  <TextEncoding>134217984</TextEncoding>
  <ItemName>kNodeTypeBoolean</ItemName>
  <ItemType>2</ItemType>
  <ItemDef>2</ItemDef>
  <ItemFlags>0</ItemFlags>
 </Constant>
</block>
</RBProject>
